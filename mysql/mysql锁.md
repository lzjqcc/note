## MySQL锁

> 表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突概率最高，并发度最低。MyISAM引擎属于这种类型
>
> 行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突概率最低，并发最高。InnoDB引擎
>
> 页面锁：开销和加锁处于标记锁和行级锁之间；会出现死锁；锁定粒度介于表锁和行锁之间，并发一般。NDB引擎

locak table 表名 read;//加读锁

//对表进行操作

unlocak tables;//释放锁

### 表级锁

​	MyISAM只支持表锁

1. 加读锁。不会影响其他进程对同一表读取，但是会阻塞同一表的写操作
2. 加写锁。对同一张表的读和写操作都会阻塞，只有当写锁释放后，才能进行其他操作。

### 行级锁

​	InnoDB存储引擎是通过给索引的索引项加锁来实现的：只有通过索引条件检索数据，InnoDB才会使用行级锁，否则使用表锁。

### MyISAM引擎

每张MyISAM存放以下三种文件：

> 数据文件MYD
>
> 索引文件MYI
>
> 文件存放表格定义frm

### InnoDB引擎

两种表空间管理模式

#### 共享表空间

​	数据文件:

​	ibdata1.......ibdataN:这里面存放**元数据**(列名、数据库名、用户名、版本名以及从SHOW语句得到的结果中的大部分字符串)，

数据，索引，回滚日志undo log，插入合并缓冲

​	ib_logfile0....3:保存重做事务日志 redo log



#### 独立表空间

​	数据文件

​	ibd:数据，索引，回滚日志undo log，插入合并缓冲

​	frm：文件存放表格定义

### MyISAM引擎和InnoDB比较

> MyISAM是非事务安全型，InnoDB事务安全
>
> MyISAM锁是表级锁，开销小。InnoDB支持表级锁外还支持行级锁，锁管理开销大，支持更好的并发写操作。
>
> MyISAM效率优于InnoDB，小新应用可以考虑使用MyISAM
>
> InnoDB表比MyISAM表更安全

​	InnoDB每秒支持1549的并发操作。MyISAM每秒支持156操作，且MyISAM的写操作优先级比读操作高，因此在高并发的时候查询数据会很慢。

建议优先使用InnoDB引擎

### 事务隔离

​	事务隔离是是通过锁来实现的，事务隔离保证了一个会话没有执行完成**之前**，其他会话不能够查看到他中间过程。保证了数据的完整性。

#### 事务隔离水平

​	

|      |      |      |      |      |
| ---- | ---- | ---- | ---- | ---- |
|      |      |      |      |      |
|      |      |      |      |      |
|      |      |      |      |      |

（非提交读取）脏读：能够从别的事务中读取还没有提交的的更新数据

​	不可重复读取(在一次事务中，两次读取的数据不一致)：是在某一事务处理中对**同一数据**读取，但由于其他事务处理的更新操作读取的数据发生改变

​	可重复读取：在一次事务中,两次读取的数据是一致的。